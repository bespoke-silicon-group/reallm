from structs.Base import Base
from structs.Chip import Chip
from structs.Package import Package
from structs.Server import Server
from structs.IO import IO
from structs.Memory import Memory
from typing import Optional, List
from dataclasses import dataclass
import multiprocessing

def make_iterable(x):
  if isinstance(x, List):
    return x
  else:
    return [x]

# Generated by Copilot
def multi_loops(loops: List[List]) -> List[List]:
  '''
  Given a list of loops, return a list of all combinations of the loops.
  '''
  if len(loops) == 1:
    return [[x] for x in loops[0]]
  else:
    result = []
    for x in loops[0]:
      for y in multi_loops(loops[1:]):
        result.append([x] + y)
    return result


@dataclass
class ChipPerfConfig:
  perf: float | List[float]
  sram: float | List[float]
  sram_bw: int | List[int]

@dataclass
class ChipAreaConfig:
  area: int | List[int]
  mac_area_ratio: float | List[float]
  operational_intensity: float | List[float]

@dataclass
class ChipConfig(Base):
  '''
  To define a chip, you should either give the perf, sram and bandwidth, 
  or area and mac_ratio and operational intensity
  '''
  yaml_config: dict

  core_config: Optional[ChipPerfConfig | ChipAreaConfig] = None
  pkg_io: Optional[IO | List[IO]] = None # chip to chip IO between packages
  chip_io: Optional[IO | List[IO]] = None # chip to chip IO in the same package
  other_area: float | List[float] = 0.0 # chip area except SRAM and compute units 
  core_ratio: float | List[float] = 0.7 # core area ratio

  def update(self) -> None:
    # off_package_io = self.config['off_package_io']
    if 'in_package_io' in self.yaml_config:
      in_pkg_io_config = self.yaml_config['in_package_io']
      if isinstance(in_pkg_io_config, dict):
        self.chip_io = IO(**in_pkg_io_config)
    if 'off_package_io' in self.yaml_config:
      off_pkg_io_config = self.yaml_config['off_package_io']
      if isinstance(off_pkg_io_config, dict):
        self.pkg_io = IO(**off_pkg_io_config)
    
    if 'area' in self.yaml_config:
      self.core_config = ChipAreaConfig(area=self.yaml_config['area'],
                                        mac_area_ratio=self.yaml_config['mac_area_ratio'],
                                        operational_intensity=self.yaml_config['operational_intensity'])
    elif 'perf' in self.yaml_config:
      self.core_config = ChipPerfConfig(perf=self.yaml_config['perf'],
                                        sram=self.yaml_config['sram'],
                                        sram_bw=self.yaml_config['sram_bw'])
    
    if 'other_area' in self.yaml_config:
      self.other_area = self.yaml_config['other_area']
    if 'core_ratio' in self.yaml_config:
      self.core_ratio = self.yaml_config['core_ratio']

  def explore(self, verbose: bool = False) -> List[Chip]:
    chips = []
    chip_io_options = make_iterable(self.chip_io)
    pkg_io_options = make_iterable(self.pkg_io)
    num = 0
    for chip_io in chip_io_options:
      for pkg_io in pkg_io_options:
        if isinstance(self.core_config, ChipAreaConfig):
          area_options = make_iterable(self.core_config.area)
          mac_area_ratio_options = make_iterable(self.core_config.mac_area_ratio)
          operational_intensity_options = make_iterable(self.core_config.operational_intensity)
          for area in area_options:
            for mac_area_ratio in mac_area_ratio_options:
              for operational_intensity in operational_intensity_options:
                chip = Chip(chip_id=num, area=area, mac_ratio=mac_area_ratio, 
                            operational_intensity=operational_intensity,
                            chip2chip_io=chip_io, pkg2pkg_io=pkg_io)
                if chip.valid:
                  chips.append(chip)
                  num += 1
                elif verbose:
                  print(f'Invalid chip design: {chip.invalid_reason}')
        elif isinstance(self.core_config, ChipPerfConfig):
          perf_options = make_iterable(self.core_config.perf)
          sram_options = make_iterable(self.core_config.sram)
          sram_bw_options = make_iterable(self.core_config.sram_bw)
          for perf in perf_options:
            for sram in sram_options:
              for sram_bw in sram_bw_options:
                chip = Chip(chip_id=num, perf=perf, sram=sram, sram_bw=sram_bw,
                            chip2chip_io=chip_io, pkg2pkg_io=pkg_io)
                if chip.valid:
                  chips.append(chip)
                  num += 1
                elif verbose:
                  print(f'Invalid chip design: {chip.invalid_reason}')
        else:
          raise Warning('wrong core_config type')
    print(f'Found {num} valid chip designs.')
    return chips

@dataclass
class PackageConfig(Base):
  '''
  Package configuration given a chip.
  '''
  yaml_config: dict

  num_chips: Optional[int | List[int]] = None
  mem_3d: Optional[Memory | List[Memory]] = None
  mem_side: Optional[Memory | List[Memory]] = None
  num_mem_side: int | List[int] = 0

  def update(self) -> None:
    self.num_chips = self.yaml_config['num_chips']
    if 'mem_3d' in self.yaml_config:
      mem_3d_config = self.yaml_config['mem_3d']
      if mem_3d_config is not None:
        self.mem_3d = Memory(**mem_3d_config)
    if 'mem_side' in self.yaml_config:
      mem_side_config = self.yaml_config['mem_side']
      if mem_side_config is not None:
        self.mem_side = Memory(**mem_side_config)
    self.num_mem_side = self.yaml_config.get('num_mem_side', 0)

  def explore(self, chips: List[Chip], verbose: bool = False) -> List[Package]:
    pkgs = []
    num_chips_options = make_iterable(self.num_chips)
    mem_3d_options = make_iterable(self.mem_3d)
    mem_side_options = make_iterable(self.mem_side)
    num_mem_side_options = make_iterable(self.num_mem_side)
    num = 0
    for chip in chips:
      for num_chips in num_chips_options:
        for mem_3d in mem_3d_options:
          for mem_side in mem_side_options:
            for num_mem_side in num_mem_side_options:
              pkg = Package(chip=chip, num_chips=num_chips, mem_3d=mem_3d, mem_side=mem_side, num_mem_side=num_mem_side)
              if pkg.valid:
                pkgs.append(pkg)    
                num += 1
              elif verbose:
                print(f'Invalid package design: {pkg.invalid_reason}')
    print(f'Found {num} valid package designs.')
    return pkgs

@dataclass
class ServerConfig(Base):
  '''
  Server configuration given a package.
  '''
  yaml_config: dict

  packages_per_lane: Optional[int | List[int]] = None
  server_io: Optional[IO | List[IO]] = None
  num_lanes: int | List[int] = 8

  def update(self) -> None:
    self.packages_per_lane = self.yaml_config['packages_per_lane']
    self.server_io = IO(**self.yaml_config['io'])
    if 'num_lanes' in self.yaml_config:
      self.num_lanes = self.yaml_config['num_lanes']

  def explore(self, pkgs: List[Package], verbose: bool = False) -> List[Server]:
    packages_per_lane_options = make_iterable(self.packages_per_lane)
    server_io_options = make_iterable(self.server_io)
    num_lanes_options = make_iterable(self.num_lanes)
    srv_specs = []
    for pkg in pkgs:
      for packages_per_lane in packages_per_lane_options:
        for num_lanes in num_lanes_options:
          for server_io in server_io_options:
            srv_specs.append((pkg, packages_per_lane, server_io, num_lanes, verbose))
    num_cores = multiprocessing.cpu_count()
    with multiprocessing.Pool(processes=num_cores) as pool:
      results = pool.starmap(self._eval_server, srv_specs)

    valid_servers = [srv for srv in results if srv != None]
    print(f'Found {len(valid_servers)} valid server designs.')

    return valid_servers
  
  def _eval_server(self, pkg: Package, 
                   packages_per_lane: int, 
                   server_io: IO,
                   num_lanes: int,
                   verbose: bool = False) -> Optional[Server]:
    srv = Server(package=pkg, 
                 packages_per_lane=packages_per_lane, 
                 io=server_io,
                 num_lanes=num_lanes)
    if srv.valid:
      return srv
    else:
      if verbose:
        print(f'Invalid server design: {srv.invalid_reason}')
      return None
  
@dataclass
class FixedDesignConfig:
  name: str
  chip_perf: float # flops per second
  chip_sram: float # bytes
  chip_sram_bw: int # bytes per second
  pkg2pkg_io: IO # chip to chip IO between packages
  num_chips_per_package: int
  pkgs_per_lane: int
  num_lanes: int
  srv2srv_io: IO # server to server IO

  chip2chip_io: Optional[IO] = None # chip to chip IO in the same package
  mem_3d: Optional[Memory] = None
  mem_side: Optional[Memory] = None
  num_mem_side: int = 0

  def eval(self) -> Optional[Server]:
    chip = Chip(chip_id=self.name, 
                perf=self.chip_perf, 
                sram=self.chip_sram, 
                sram_bw=self.chip_sram_bw,
                chip2chip_io=self.chip2chip_io, 
                pkg2pkg_io=self.pkg2pkg_io)
    if chip.valid:
      # Package Configurations
      pkg = Package(chip=chip, 
                    num_chips=self.num_chips_per_package, 
                    mem_3d=self.mem_3d, 
                    mem_side=self.mem_side, 
                    num_mem_side=self.num_mem_side)
      if pkg.valid:
        # Server Configurations
        srv = Server(package=pkg, 
                     packages_per_lane=self.pkgs_per_lane, 
                     io=self.srv2srv_io,
                     num_lanes=self.num_lanes)
        if srv.valid:
          return srv
        else:
          print(f'Invalid server design: {srv.invalid_reason}')
          return None
      else:
        print(f'Invalid package design: {pkg.invalid_reason}')
        return None
    else:
      print(f'Invalid chip design: {chip.invalid_reason}')
      return None



